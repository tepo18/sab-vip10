`import os
import json
import urllib.parse


def parse_link(link):
    link = link.strip()
    parsed = {}

    if link.startswith("vless://"):
        protocol = "vless"
    else:
        return None, None

    try:
        main_part = link.split("://")[1]
        if "#" in main_part:
            main_part, remark = main_part.split("#", 1)
        else:
            remark = ""

        if "?" in main_part:
            addr_port, params = main_part.split("?", 1)
            query = urllib.parse.parse_qs(params)
        else:
            addr_port = main_part
            query = {}

        if '@' in addr_port:
            user, host_port = addr_port.split("@", 1)
        else:
            user = ""
            host_port = addr_port

        if ':' in host_port:
            address, port = host_port.split(":", 1)
        else:
            address, port = host_port, "443"

        parsed = {
            "protocol": protocol,
            "address": address,
            "port": int(port) if port.isdigit() else 443,
            "id": user,
            "params": {k: v[0] for k, v in query.items()},
            "remark": urllib.parse.unquote(remark)
        }
        return protocol, parsed

    except Exception:
        return None, None


def build_fragment_list(configs):
    fragments = []

    for i, cfg in enumerate(configs):
        outbound = {
            "tag": "proxy",
            "protocol": "vless",
            "settings": {
                "vnext": [{
                    "address": cfg["address"],
                    "port": cfg["port"],
                    "users": [{
                        "id": cfg["id"],
                        "encryption": cfg["params"].get("encryption", "none"),
                        "flow": cfg["params"].get("flow", "")
                    }]
                }]
            },
            "streamSettings": {
                "network": cfg["params"].get("type", "ws"),
                "security": cfg["params"].get("security", "tls"),
                "sockopt": {
                    "dialerProxy": "fragment"
                },
                "tlsSettings": {
                    "serverName": cfg["params"].get("sni", cfg["params"].get("host", cfg["address"])),
                    "fingerprint": cfg["params"].get("fp", "chrome"),
                    "alpn": cfg["params"].get("alpn", "").split(",") if "alpn" in cfg["params"] else ["http/1.1"]
                },
                "wsSettings": {
                    "path": cfg["params"].get("path", "/"),
                    "headers": {
                        "Host": cfg["params"].get("host", cfg["address"])
                    }
                }
            }
        }

        fragment = {
            "remarks": cfg["remark"] or f"üí¶ {i+1} - VLESS",
            "log": {"loglevel": "warning"},
            "dns": {
                "servers": [
                    {
                        "address": "https://8.8.8.8/dns-query",
                        "tag": "remote-dns"
                    },
                    {
                        "address": "8.8.8.8",
                        "domains": [
                            f"full:{cfg['address']}"
                        ],
                        "skipFallback": True
                    }
                ],
                "queryStrategy": "UseIP",
                "tag": "dns"
            },
            "inbounds": [
                {
                    "port": 10808,
                    "protocol": "socks",
                    "settings": {
                        "auth": "noauth",
                        "udp": True,
                        "userLevel": 8
                    },
                    "sniffing": {
                        "destOverride": ["http", "tls"],
                        "enabled": True,
                        "routeOnly": True
                    },
                    "tag": "socks-in"
                },
                {
                    "port": 10853,
                    "protocol": "dokodemo-door",
                    "settings": {
                        "address": "1.1.1.1",
                        "network": "tcp,udp",
                        "port": 53
                    },
                    "tag": "dns-in"
                }
            ],
            "outbounds": [
                outbound,
                {
                    "tag": "fragment",
                    "protocol": "freedom",
                    "settings": {
                        "fragment": {
                            "packets": "tlshello",
                            "length": "100-200",
                            "interval": "1-1"
                        },
                        "domainStrategy": "UseIPv4v6"
                    }
                }
            ],
            "routing": {
                "domainStrategy": "IPIfNonMatch",
                "rules": [
                    {
                        "inboundTag": ["dns-in"],
                        "outboundTag": "dns-out",
                        "type": "field"
                    },
                    {
                        "network": "tcp",
                        "outboundTag": "proxy",
                        "type": "field"
                    }
                ]
            }
        }

        fragments.append(fragment)

    return fragments


def save_output(configs):
    while True:
        print("\nSelect output type:\n1. Fragmented Config (for V2Ray)\n2. Simple Raw JSON")
        choice = input("Enter your choice (1 or 2): ").strip()

        file_name = input("Output file name (without extension): ").strip()
        save_path = "/sdcard/Download/almasi98"
        os.makedirs(save_path, exist_ok=True)
        full_path = os.path.join(save_path, f"{file_name}.json")

        if choice == "1":
            output = build_fragment_list(configs)
        else:
            output = configs

        with open(full_path, "w", encoding="utf-8") as f:
            json.dump(output, f, indent=2, ensure_ascii=False)

        print(f"\n‚úÖ Saved to: {full_path}")

        again = input("\nDo you want to export again with same input? (y/n): ").strip().lower()
        if again != "y":
            break


def main():
    print("=" * 40)
    print("Paste your configs (Press ENTER twice to finish):")
    lines = []
    while True:
        line = input()
        if line.strip() == "":
            break
        lines.append(line.strip())

    parsed_configs = []
    for line in lines:
        proto, parsed = parse_link(line)
        if proto:
            parsed_configs.append(parsed)
        else:
            print(f"Skipped: {line}")

    if not parsed_configs:
        print("‚ùå No valid configs parsed.")
        return

    save_output(parsed_configs)


if name == "main":
    main()`
