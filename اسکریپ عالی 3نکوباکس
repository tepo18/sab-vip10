import os
import json
import urllib.parse
import yaml


def parse_link(link):
    link = link.strip()
    if link.startswith("vless://"):
        protocol = "vless"
    else:
        return None, None

    try:
        main_part = link.split("://")[1]
        remark = ""
        if "#" in main_part:
            main_part, remark = main_part.split("#", 1)

        if "?" in main_part:
            addr_port, params = main_part.split("?", 1)
            query = urllib.parse.parse_qs(params)
        else:
            addr_port = main_part
            query = {}

        if '@' in addr_port:
            user, host_port = addr_port.split("@", 1)
        else:
            user = ""
            host_port = addr_port

        if ':' in host_port:
            address, port = host_port.split(":", 1)
        else:
            address, port = host_port, "443"

        parsed = {
            "protocol": protocol,
            "address": address,
            "port": int(port),
            "id": user,
            "params": {k: v[0] for k, v in query.items()},
            "remark": urllib.parse.unquote(remark)
        }
        return protocol, parsed

    except Exception:
        return None, None


def build_fragment_list(configs):
    fragments = []
    for i, cfg in enumerate(configs):
        fragment = {
            "remarks": cfg["remark"] or f"üí¶ {i+1} - VLESS",
            "log": {"loglevel": "warning"},
            "dns": {
                "servers": [
                    {"address": "https://8.8.8.8/dns-query", "tag": "remote-dns"},
                    {"address": "8.8.8.8", "domains": [f"full:{cfg['address']}"], "skipFallback": True}
                ],
                "queryStrategy": "UseIP",
                "tag": "dns"
            },
            "inbounds": [
                {
                    "port": 10808,
                    "protocol": "socks",
                    "settings": {"auth": "noauth", "udp": True, "userLevel": 8},
                    "sniffing": {
                        "destOverride": ["http", "tls"],
                        "enabled": True,
                        "routeOnly": True
                    },
                    "tag": "socks-in"
                },
                {
                    "port": 10853,
                    "protocol": "dokodemo-door",
                    "settings": {"address": "1.1.1.1", "network": "tcp,udp", "port": 53},
                    "tag": "dns-in"
                }
            ],
            "outbounds": [
                {
                    "tag": "proxy",
                    "protocol": "vless",
                    "settings": {
                        "vnext": [{
                            "address": cfg["address"],
                            "port": cfg["port"],
                            "users": [{
                                "id": cfg["id"],
                                "encryption": cfg["params"].get("encryption", "none"),
                                "flow": cfg["params"].get("flow", "")
                            }]
                        }]
                    },
                    "streamSettings": {
                        "network": cfg["params"].get("type", "ws"),
                        "security": cfg["params"].get("security", "tls"),
                        "sockopt": {"dialerProxy": "fragment"},
                        "tlsSettings": {
                            "serverName": cfg["params"].get("sni", cfg["params"].get("host", cfg["address"])),
                            "fingerprint": cfg["params"].get("fp", "chrome"),
                            "alpn": cfg["params"].get("alpn", "").split(",") if "alpn" in cfg["params"] else ["http/1.1"]
                        },
                        "wsSettings": {
                            "path": cfg["params"].get("path", "/"),
                            "headers": {"Host": cfg["params"].get("host", cfg["address"])}
                        }
                    }
                },
                {
                    "tag": "fragment",
                    "protocol": "freedom",
                    "settings": {
                        "fragment": {"packets": "tlshello", "length": "100-200", "interval": "1-1"},
                        "domainStrategy": "UseIPv4v6"
                    }
                }
            ],
            "routing": {
                "domainStrategy": "IPIfNonMatch",
                "rules": [
                    {"inboundTag": ["dns-in"], "outboundTag": "dns-out", "type": "field"},
                    {"network": "tcp", "outboundTag": "proxy", "type": "field"}
                ]
            }
        }
        fragments.append(fragment)
    return fragments


def build_neko_format(configs):
    neko_list = []
    for i, cfg in enumerate(configs):
        remark = cfg.get("remark") or f"Neko-{i+1}"
        params = cfg.get("params", {})
        user_id = cfg.get("id", "")

        neko_node = {
            "remarks": remark,
            "server": cfg["address"],
            "port": cfg["port"],
            "uuid": user_id,
            "alterId": 0,
            "security": params.get("encryption", "none"),
            "network": params.get("type", "ws"),
            "ws-path": params.get("path", "/"),
            "ws-headers": {
                "Host": params.get("host", cfg["address"])
            },
            "tls": True if params.get("security", "tls") == "tls" else False,
            "sni": params.get("sni", params.get("host", cfg["address"]))
        }
        neko_list.append(neko_node)
    return neko_list


def build_clash_yaml(configs):
    proxies = []
    proxy_names = []

    for i, cfg in enumerate(configs):
        name = cfg["remark"] or f"Node-{i+1}"
        proxy = {
            "name": name,
            "type": "vless",
            "server": cfg["address"],
            "port": cfg["port"],
            "uuid": cfg["id"],
            "tls": True if cfg["params"].get("security", "tls") == "tls" else False,
            "udp": True,
            "servername": cfg["params"].get("sni", cfg["params"].get("host", cfg["address"])),
            "fingerprint": cfg["params"].get("fp", "chrome"),
            "network": cfg["params"].get("type", "ws"),
            "ws-opts": {
                "path": cfg["params"].get("path", "/"),
                "headers": {
                    "Host": cfg["params"].get("host", cfg["address"])
                }
            }
        }
        proxies.append(proxy)
        proxy_names.append(name)

    clash_config = {
        "proxies": proxies,
        "proxy-groups": [
            {
                "name": "‚ôªÔ∏è Auto",
                "type": "url-test",
                "proxies": proxy_names,
                "url": "http://www.gstatic.com/generate_204",
                "interval": 300
            },
            {
                "name": "üî∞ All",
                "type": "select",
                "proxies": proxy_names
            }
        ],
        "rules": [
            "MATCH,üî∞ All"
        ]
    }

    return clash_config


def save_output(configs):
    save_path = "/sdcard/Download/almasi98"
    os.makedirs(save_path, exist_ok=True)

    while True:
        print("\nüß© Select output type:")
        print("1. Fragmented V2Ray")
        print("2. Raw JSON Array")
        print("3. Nekobox JSON (vless compatible)")
        print("4. Clash Meta YAML")

        choice = input("üî¢ Your choice (1/2/3/4): ").strip()
        file_name = input("üìÅ Output file name (no extension): ").strip()

        if choice == "4":
            full_path = os.path.join(save_path, f"{file_name}.yaml")
        else:
            full_path = os.path.join(save_path, f"{file_name}.json")

        if choice == "1":
            output = build_fragment_list(configs)
            with open(full_path, "w", encoding="utf-8") as f:
                json.dump(output, f, indent=2, ensure_ascii=False)
        elif choice == "2":
            with open(full_path, "w", encoding="utf-8") as f:
                json.dump(configs, f, indent=2, ensure_ascii=False)
        elif choice == "3":
            output = build_neko_format(configs)
            with open(full_path, "w", encoding="utf-8") as f:
                json.dump(output, f, indent=2, ensure_ascii=False)
        elif choice == "4":
            output = build_clash_yaml(configs)
            with open(full_path, "w", encoding="utf-8") as f:
                yaml.dump(output, f, sort_keys=False)
        else:
            print("‚ùå Invalid choice.")
            continue

        print(f"\n‚úÖ Saved to: {full_path}")
        again = input("üîÅ Export again? (y/n): ").strip().lower()
        if again != "y":
            break


def main():
    print("=" * 40)
    print("üì• Paste your VLESS links (ENTER twice to finish):")
    lines = []
    while True:
        line = input()
        if line.strip() == "":
            break
        lines.append(line.strip())

    parsed_configs = []
    for line in lines:
        proto, parsed = parse_link(line)
        if parsed:
            parsed_configs.append(parsed)
        else:
            print(f"‚ö†Ô∏è Skipped: {line}")

    if not parsed_configs:
        print("‚ùå No valid configs.")
        return

    save_output(parsed_configs)


if __name__ == "__main__":
    main()
